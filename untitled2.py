# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JbOPpwY9jRrmpO6lAlIifM1JrQ_TA4TW
"""

def check_brackets(expression):
    stack = []
    opening_bracket = '('
    closing_bracket = ')'

    for char in expression:     #Она получает целочисленное значение (код символа) и возвращает символ, который соответствует этому коду
        if char == opening_bracket:
            stack.append(char)
        elif char == closing_bracket:
            if not stack or stack[-1] != opening_bracket:
                return False
            stack.pop()    #pop() – удаляет самый верхний элемент

    if stack:
        return False
    return True

input_string1 = '((dsasdas((das(d)das)d)asd)da)'
input_string2 = '(f(gfhd((hgfdg((fghh)dads)das))ds)adddads())))'

print(check_brackets(input_string1))
print(check_brackets(input_string2))

"""Этот код определяет, верно ли составлены скобки в заданном выражении expression.

Создается пустой стек (список stack).
Указываются открывающая и закрывающая скобки.
Происходит итерация по каждому символу в выражении expression.
Если символ - открывающая скобка (, то он добавляется в стек.
Если символ - закрывающая скобка ), то проверяется, что перед этим в стеке находится соответствующая открывающая скобка (, иначе возвращается False.
Если после окончания итерации стек не пуст (т.е., есть открытая скобка, для которой не нашлась закрывающая), то возвращается False. В противном случае, возвращается True.
После определения функции check_brackets, определены две строки input_string1 и input_string2.
Для каждой строки input_string1 и input_string2 вычисляется функция check_brackets, и результат выводится на экран.
Таким образом, код проверяет правильность расстановки скобок в строке и выводит True, если все скобки соответствуют друг другу, и False в противном случае.
"""

class Stack:
    def __init__(self, max_length):
        self.stack = []
        self.max_length = max_length

    def push(self, element):
        if len(self.stack) >= self.max_length:
            raise Exception("Stack overflow")
        self.stack.append(element)

    def pop(self):
        if not self.stack:
            raise Exception("Stack is empty")
        return self.stack.pop()

    def top(self):
        if not self.stack:
            raise Exception("Stack is empty")
        return self.stack[-1]

    def is_empty(self):
        return len(self.stack) == 0

    def __len__(self):
        return len(self.stack)


s = Stack(5)
s.push(1)
s.push(2)
s.push(3)
print(s.pop())
print(s.top())
print(s.is_empty())
print(len(s))

"""Этот код представляет класс Stack для реализации стека (структуры данных Last-In-First-Out, LIFO) с использованием списков в Python.

__init__: конструктор класса, который инициализирует пустой стек (self.stack) с максимальной длиной (max_length), переданной в качестве аргумента.

push: метод добавления нового элемента в вершину стека. Если текущая длина стека больше или равна максимальной длине, генерируется исключение "Stack overflow".

pop: метод удаления и возврата элемента из вершины стека. Если стек пустой, генерируется исключение "Stack is empty".

top: метод возвращает элемент из вершины стека без его удаления. Если стек пустой, генерируется исключение "Stack is empty".

is_empty: метод проверки стека на пустоту.

__len__: метод возвращает текущую длину стека.

Далее, создается экземпляр класса Stack с максимальной длиной 5, и выполняются следующие операции:

Добавление элементов 1, 2 и 3 в стек.
Удаление и возврат элемента 3 из стека с помощью метода pop.
Получение элемента 2 из вершины стека без его удаления с помощью метода top.
Проверка стека на пустоту с помощью метода is_empty.
Получение текущей длины стека с помощью функции len.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            last_node = self.head
            while last_node.next:
                last_node = last_node.next
            last_node.next = new_node

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def delete(self, data):
        current_node = self.head
        if current_node and current_node.data == data:
            self.head = current_node.next
            current_node = None
            return
        prev = None
        while current_node and current_node.data != data:
            prev = current_node
            current_node = current_node.next
        if current_node is None:
            return
        prev.next = current_node.next
        current_node = None

    def display(self):
        current_node = self.head
        while current_node:
            print(current_node.data, end=' -> ')
            current_node = current_node.next
        print('None')


linked_list = LinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
linked_list.append(4)
linked_list.display()

linked_list.prepend(0)
linked_list.display()
linked_list.delete(2)
linked_list.display()

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            last_node = self.head
            while last_node.next:
                last_node = last_node.next
            last_node.next = new_node

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def delete(self, data):
        current_node = self.head
        if current_node and current_node.data == data:
            self.head = current_node.next
            current_node = None
            return
        prev = None
        while current_node and current_node.data != data:
            prev = current_node
            current_node = current_node.next
        if current_node is None:
            return
        prev.next = current_node.next
        current_node = None

    def display(self):
        current_node = self.head
        while current_node:
            print(current_node.data, end=' -> ')
            current_node = current_node.next
        print('None')



linked_list = LinkedList()
linked_list.append(2)
linked_list.append(3)
linked_list.append(4)
linked_list.display()

linked_list.prepend(1)
linked_list.display()

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            last_node = self.head
            while last_node.next:
                last_node = last_node.next
            last_node.next = new_node
            new_node.prev = last_node

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        if self.head:
            self.head.prev = new_node
        self.head = new_node

    def delete(self, data):
        current_node = self.head
        while current_node and current_node.data != data:
            current_node = current_node.next
        if current_node is None:
            return
        if current_node.prev:
            current_node.prev.next = current_node.next
        else:
            self.head = current_node.next
        if current_node.next:
            current_node.next.prev = current_node.prev
        current_node = None

    def display(self):
        current_node = self.head
        while current_node:
            print(current_node.data, end=' -> ')
            current_node = current_node.next
        print('None')



doubly_linked_list = DoublyLinkedList()
doubly_linked_list.append(2)
doubly_linked_list.append(3)
doubly_linked_list.append(4)
doubly_linked_list.display()

doubly_linked_list.prepend(1)
doubly_linked_list.display()

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            last_node = self.head
            while last_node.next:
                last_node = last_node.next
            last_node.next = new_node
            new_node.prev = last_node

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        if self.head:
            self.head.prev = new_node
        self.head = new_node

    def delete(self, data):
        current_node = self.head
        while current_node and current_node.data != data:
            current_node = current_node.next
        if current_node is None:
            return
        if current_node.prev:
            current_node.prev.next = current_node.next
        else:
            self.head = current_node.next
        if current_node.next:
            current_node.next.prev = current_node.prev
        current_node = None

    def display(self):
        current_node = self.head
        while current_node:
            print(current_node.data, end=' -> ')
            current_node = current_node.next
        print('None')



doubly_linked_list = DoublyLinkedList()
doubly_linked_list.append(2)
doubly_linked_list.append(3)
doubly_linked_list.append(4)
doubly_linked_list.display()

doubly_linked_list.prepend(1)
doubly_linked_list.display()

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.tail = None

    def enqueue(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node

    def dequeue(self):
        if not self.head:
            raise ValueError("Queue is empty")
        data = self.head.data
        self.head = self.head.next
        if not self.head:
            self.tail = None
        return data

    def is_empty(self):
        return not self.head


queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)

print(queue.dequeue())
print(queue.dequeue())
queue.enqueue(4)
print(queue.dequeue())
print(queue.dequeue())